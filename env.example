# =========================
# Amber + GoodWe + AlphaESS
# =========================
#
# Notes on pricing sign:
#   feedIn > 0.0c  => you GET PAID to export
#   feedIn < 0.0c  => you PAY to export
#
# The script treats "export would cost money" as:
#   export_costs = (feedIn < EXPORT_COST_THRESHOLD_C)
# Default threshold is 0.0c.

# -------------------------
# Amber API (REQUIRED)
# -------------------------
AMBER_API_KEY=psk_
AMBER_SITE_ID=
EXPORT_COST_THRESHOLD_C=0.0

# How often Amber prices are interval-based (AU often 5 minutes)
AMBER_RESOLUTION_MIN=5

# Optional: also fetch usage (used only for extra logging/telemetry)
AMBER_FETCH_USAGE=1
AMBER_USAGE_RESOLUTION_MIN=5

# If Amber becomes stale/unavailable beyond this, script assumes export MAY be costly (fail-safe)
AMBER_MAX_STALE_SEC=900


# -------------------------
# AlphaESS OpenAPI (recommended)
# -------------------------
ALPHAESS_OPENAPI_ENABLED=1

# From https://open.alphaess.com/
ALPHAESS_APP_ID=alpha
ALPHAESS_APP_SECRET=
#
# ALPHAESS_SYS_SN can be either:
#   - the full sysSn string, OR
#   - a small number (1-based) to select an item from your account list (convenience)
ALPHAESS_SYS_SN=
ALPHAESS_UNIT_INDEX=1

# SSL verify (leave enabled unless debugging cert/proxy issues)
ALPHAESS_VERIFY_SSL=1

# If these signs are reversed in your Alpha data, flip these to 0
# Script normalises internally to:
#   pBat: + = charging, - = discharging
#   pGrid:+ = import,   - = export
ALPHAESS_PBAT_POSITIVE_IS_CHARGE=1
ALPHAESS_PGRID_POSITIVE_IS_IMPORT=1

# Treat |pBat| below this as 'idle' (noise floor)
ALPHAESS_PBAT_IDLE_THRESHOLD_W=50

# Alpha polling behaviour
ALPHAESS_MIN_POLL_INTERVAL_SEC=15
ALPHAESS_POLL_TIMEOUT_SEC=12.0
ALPHAESS_MAX_STALE_SEC=30


# -------------------------
# AlphaESS control tuning (when export_costs=True)
# -------------------------

# Grid feedback gain: how aggressively we adjust PV limit based on pGrid export/import
ALPHAESS_GRID_FEEDBACK_GAIN=1.0

# Bias slightly toward importing (W) to avoid tiny accidental exports
ALPHAESS_GRID_IMPORT_BIAS_W=50

# When battery is NOT full, biasing to import can cause SmartShift to discharge; default is 0.
ALPHAESS_GRID_IMPORT_BIAS_W_WHEN_NOT_FULL=0

# Consider battery "full" at/above this SOC (%)
# (Default 99.5 so integer 100% counts as full)
ALPHAESS_FULL_SOC_PCT=99.5



# Optional "auto charge headroom" behaviour (when export_costs=True):
# This is a *kick-start* to help charging begin when the battery is idle/discharging.
# It does NOT force extra headroom once the battery is already charging (important near full SOC where
# the battery naturally tapers charge power).
#
# If SOC is below this AND the battery is not charging, we assume it can absorb up to AUTO_CHARGE_W
# (clamped by AUTO_CHARGE_MAX_W) and keep PV headroom for it.
# Set ALPHAESS_AUTO_CHARGE_W=0 to disable.
ALPHAESS_AUTO_CHARGE_BELOW_SOC_PCT=99.5
ALPHAESS_AUTO_CHARGE_W=1500
ALPHAESS_AUTO_CHARGE_MAX_W=3000


# -------------------------
# GoodWe Modbus-TCP
# -------------------------
# Preferred:
GOODWE_HOST=192.168.1.10:502
GOODWE_UNIT=247

# Backwards-compatible aliases (optional):
# GOODWE=192.168.1.10:502
# UNIT=247

# Timeouts/retries (preferred)
MODBUS_TIMEOUT_SEC=3.0
MODBUS_RETRIES=3

# Backwards-compatible aliases (optional):
# TIMEOUT=3.0
# RETRIES=3

# Auto-reconnect on socket errors (Broken pipe, reset, timeout, etc)
MODBUS_RECONNECT_ON_ERROR=1
MODBUS_RECONNECT_MIN_BACKOFF_SEC=1.0
MODBUS_RECONNECT_MAX_BACKOFF_SEC=30.0


# -------------------------
# GoodWe export limiting registers / mode
# -------------------------
# Modes:
#   active_pct -> write % limit directly into GOODWE_ACTIVE_PCT_REG (default 256)
#   pct        -> write % into GOODWE_EXPORT_PCT_REG (292) and %*10 into (293)
GOODWE_EXPORT_LIMIT_MODE=active_pct

# Typical for GW5000 DNS export-limit regs
GOODWE_EXPORT_SWITCH_REG=291
GOODWE_EXPORT_PCT_REG=292
GOODWE_EXPORT_PCT10_REG=293

# Active-power % register used by "active_pct" mode
GOODWE_ACTIVE_PCT_REG=256

# Rated output of inverter (used to show "~xxxxW" estimate)
GOODWE_RATED_W=5000

# If 1: always keep export-limiting "enabled" and just move the % up/down.
# If 0: script will disable limiting when export is allowed (export_costs=False).
GOODWE_ALWAYS_ENABLED=1


# -------------------------
# Runtime telemetry registers (optional; for logging)
# -------------------------
# auto tries dns then mt; "off" disables runtime reads
RUNTIME_PROFILE=auto

# If optional runtime registers (feed/wifi/meterOK) appear unsupported (return 0xFFFF),
# the script will back off retries for this many seconds to reduce Modbus traffic.
GOODWE_RUNTIME_OPTIONAL_RETRY_SEC=300


# -------------------------
# Control loop tuning
# -------------------------
SLEEP_SECONDS=2

# Rate-limit writes to GoodWe to avoid hammering it
MIN_SECONDS_BETWEEN_WRITES=10.0

# Only write if desired % changes by >= this amount
MIN_PCT_STEP=1

# Simple smoothing (0 = none). Higher = more smoothing.
LIMIT_SMOOTHING=0.2

# Extra console output (including which pymodbus signature was used)
DEBUG=0


# -------------------------
# Logging (rotating files)
# -------------------------
# By default each process logs to ./logs/{control|ingest|api|ui}.log and also stdout.
# Set LOG_TO_STDOUT=0 to disable console logging.
LOG_DIR=logs
LOG_TO_STDOUT=1
LOG_TO_FILE=1
# LOG_LEVEL=INFO
LOG_MAX_BYTES=5242880
LOG_BACKUP_COUNT=5
# LOG_UTC=0


# -------------------------
# Event export + ingestion + UI
# -------------------------
# control.py will emit one JSON event file per loop iteration.
EVENT_EXPORT_ENABLED=1
EVENT_EXPORT_DIR=export/events

# Raw payload mode for large upstream data embedded in each event.
# - always: include raw payload every loop (largest DB)
# - on_change: include raw only when the upstream snapshot changes (recommended)
# - never: never include raw payloads
EVENT_EXPORT_AMBER_RAW_MODE=on_change
EVENT_EXPORT_ALPHA_RAW_MODE=on_change

# ingest_to_sqlite.py loads those JSON files into SQLite.
INGEST_DB_PATH=data/events.sqlite3
INGEST_PROCESSED_DIR=export/processed
INGEST_POLL_SEC=1
# If 1: delete JSON files after import. If 0: move into INGEST_PROCESSED_DIR.
INGEST_DELETE_AFTER_IMPORT=0

# Retention / slimming (to control SQLite growth)
INGEST_RETENTION_ENABLED=1
# Keep full events for this many hours, then strip raw payload fields from older rows.
INGEST_RETENTION_FULL_HOURS=48
# Delete very old rows entirely (set 0 to disable)
INGEST_RETENTION_DELETE_AFTER_DAYS=30
# How often to run retention work (seconds)
INGEST_RETENTION_EVERY_SEC=300
# Batch size per retention run
INGEST_RETENTION_SLIM_BATCH=500
# If you keep processed JSON files, optionally prune them too (days; 0 disables)
INGEST_PROCESSED_RETENTION_DAYS=0

# Optional: reduce number of rows stored by skipping near-identical consecutive events.
# This can drastically reduce SQLite growth if your loop is fast (e.g. every 2s).
#
# The UI still works, but it will update only when something changes (or at the forced heartbeat interval).
INGEST_DEDUP_ENABLED=0
# Always keep at least one event every N seconds even if unchanged (UI heartbeat)
INGEST_DEDUP_FORCE_SEC=30

# Dedupe mode:
# - telemetry: includes quantized power readings (more rows, more detail)
# - decision: decision/limits + prices + SOC (fewer rows; recommended)
# - decision_only: decision/limits + prices (fewest rows)
INGEST_DEDUP_MODE=telemetry

# Quantisation for change detection (telemetry mode)
# If you are still storing too many rows, increase WATT_STEP (e.g. 50 or 100).
INGEST_DEDUP_WATT_STEP=50
INGEST_DEDUP_PRICE_STEP=0.001
INGEST_DEDUP_SOC_STEP=0.1

# Periodic stats line in ingest.log (seconds). Set 0 to disable.
INGEST_STATS_EVERY_SEC=60

# api_server.py exposes CRUD-ish endpoints + SSE stream from SQLite.
API_DB_PATH=data/events.sqlite3
API_HOST=127.0.0.1
API_PORT=8001
API_SSE_POLL_SEC=0.5
# Comma-separated. Needed if UI is served from a different origin (host/port).
API_CORS_ORIGINS=http://localhost:8000,http://127.0.0.1:8000

# ui_server.py publishes the website and connects to the API.
UI_HOST=0.0.0.0
UI_PORT=8000

# Default: UI server proxies /api/* to the upstream API (so the browser stays same-origin).
UI_PROXY_API=1
UI_API_UPSTREAM=http://127.0.0.1:8001

# If UI_PROXY_API=0, the browser will connect directly to this base URL:
UI_API_BASE=http://127.0.0.1:8001
